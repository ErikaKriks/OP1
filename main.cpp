#include <iostream>
#include <iomanip>
#include <fstream>
#include <string>
#include <vector>
#include <stdio.h>
#include <sstream>
#include <random> // for random number generation
#include <ctime>  // for seeding the random number generator
#include <cstdlib>
#include "functions.h"
#include <chrono> // For measuring time
#include <list> 



using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::vector;
using std::list;
using std::printf;
using std::sort;
using std::ifstream;
using std::cerr;
using std::invalid_argument;
using std::runtime_error;
using std::to_string;
using std::default_random_engine;
using std::uniform_int_distribution;
using std::ofstream;
using std::left;
using std::setw;
using std::chrono::high_resolution_clock;
using std::chrono::duration;
using std::chrono::duration_cast;
using std::chrono::seconds;



int main() {

    int choice;
    int choice2;
    choice = usersChoice();
    cout << choice << endl;


    if (choice == 0) {
        // Students information will be written manually.
        
        choice2 =  usersChoiceAvgMed();
        
        int k;
        cout << "Number of students:" << endl;
        cin >> k;

        vector<Student> students;

        for (int i = 0; i < k; i++)
        {
            Student student;
            getInput(student);

            // Calculate Final Mark based on Average
            if (choice2 == 0) {
                student.finalMark = calculateFinalMarkAvg(student);
            }
            else {
                student.finalMark = calculateFinalMarkMed(student);
            }
            
            students.push_back(student);

        }

        printStudentTable(students);

        return 0;
    }


    else if (choice == 1) {
        // Students information will be autogenerated.
        int choice2;
        choice2 =  usersChoiceAvgMed();

        int k;
        cout << "Number of students:" << endl;
        cin >> k;

        vector<Student> students;
        default_random_engine generator(time(0)); // Seed the random number generator

        for (int i = 0; i < k; i++)
        {
            Student student;
            getInputAuto(student);

            // Calculate Final Mark based on Average
            if (choice2 == 0) {
                student.finalMark = calculateFinalMarkAvg(student);
            }
            else {
                student.finalMark = calculateFinalMarkMed(student);
            }

            students.push_back(student);
        }

        printStudentTable(students);

        return 0;
    }

    else if (choice == 2) {
        // Students information will be read from files and sorted out.
        vector<Student> students;
        string filename = "kursiokai.txt";

        auto start = std::chrono::high_resolution_clock::now(); // Start measuring time

        // Read student data from the file
        readStudentsFromFileVector(filename, students);

        auto end = std::chrono::high_resolution_clock::now(); // Stop measuring time
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        // Calculate Final Mark based on Average and Median of marks
        for (size_t i = 0; i < students.size(); ++i)
        {
            Student &student = students[i];

            // Calculate Final Mark based on Average
            student.finalMarkAvg = calculateFinalMarkAvg(student);

            // Calculate Final Mark based on Median
            student.finalMarkMed = calculateFinalMarkMed(student);
        }

        // Sort the students vector
        sort(students.begin(), students.end(), compareStudents);

        // Displaying a table of results
        printStudentTableAvgMed(students);

        // For testing purposes
        cout << "Total number of lines read: " << students.size() + 1 << " (including header)" << endl;
        cout << "Time taken to read the file: " << duration.count() << " microseconds" << endl;

        return 0;
    }
    
    else if (choice == 3)
    {
        choice2 = usersChoiceVectorList();
        // vector<int> numStudentsList = {1000, 10000, 100000, 1000000, 10000000};
        vector<int> numStudentsList = {10, 100}; // For testing purposes

        if (choice2 == 1) {
        // List structure will be used.

        for (int numStudents : numStudentsList) {
            // Data generation and saving
            auto startGeneration = std::chrono::high_resolution_clock::now();
            list<Student> students;
            for (int i = 1; i <= numStudents; ++i) {
                students.push_back(generateRandomStudent(i, 15)); // 15 random individual marks
            }
            string filename = "students" + to_string(numStudents) + ".txt";
            saveStudentDataToFileList(filename, students);
            auto endGeneration = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> generationTime = endGeneration - startGeneration;

            // Reading data
            auto startReading = std::chrono::high_resolution_clock::now();
            list<Student> readStudents;
            readStudentsFromFileList(filename, readStudents);
            auto endReading = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> categorizationTime = endReading - startReading;
            

            // Categorization
            auto startCategorization = std::chrono::high_resolution_clock::now();
            list<Student> failStudents;
            list<Student> passStudents;

            for (const Student& student : readStudents) {
                float finalMark = calculateFinalMarkAvg(student); // You can use either Avg or Med function
                if (finalMark < 5.0) {
                    failStudents.push_back(student);
                } else {
                    passStudents.push_back(student);
                }
            }
            
            // Sort the failStudents and passStudents lists
            failStudents.sort(compareStudents);
            passStudents.sort(compareStudents);
            auto endCategorization = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> readingTime = endCategorization - startCategorization;

            // Saving categorized data
            auto startSavingCategorized = std::chrono::high_resolution_clock::now();
            string filenameFail = "students" + to_string(numStudents) + "_fail.txt";
            string filenamePass = "students" + to_string(numStudents) + "_pass.txt";

            saveStudentDataToFileList(filenameFail, failStudents);
            saveStudentDataToFileList(filenamePass, passStudents);
            auto endSavingCategorized = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> savingCategorizedTime = endSavingCategorized - startSavingCategorized;

            cout << "Execution times for " << numStudents << " students:" << endl;
            cout << "Memory address of the data structure: " << &students << endl;
            cout << "Data generation and saving: " << generationTime.count() << " seconds" << endl;
            cout << "Reading: " << readingTime.count() << " seconds" << endl;
            cout << "Categorization: " << categorizationTime.count() << " seconds" << endl;
            cout << "Saving categorized data: " << savingCategorizedTime.count() << " seconds" << endl;
            cout << "------------------------" << endl;
        }

        return 0;
        }


        else if (choice2 == 0) {
            // Vector structure will be used.


        for (int numStudents : numStudentsList) {
            // Data generation and saving
            auto startGeneration = std::chrono::high_resolution_clock::now();
            vector<Student> students;
            for (int i = 1; i <= numStudents; ++i) {
                students.push_back(generateRandomStudent(i, 15)); // 15 random individual marks
            }
            string filename = "students" + to_string(numStudents) + ".txt";
            saveStudentDataToFileVector(filename, students);
            auto endGeneration = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> generationTime = endGeneration - startGeneration;

            // Reading data
            auto startReading = std::chrono::high_resolution_clock::now();
            vector<Student> readStudents;
            readStudentsFromFileVector(filename, readStudents);
            auto endReading = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> categorizationTime = endReading - startReading;
            

            // Categorization
            auto startCategorization = std::chrono::high_resolution_clock::now();
            vector<Student> failStudents;
            vector<Student> passStudents;

            for (const Student& student : readStudents) {
                float finalMark = calculateFinalMarkAvg(student); // You can use either Avg or Med function
                if (finalMark < 5.0) {
                    failStudents.push_back(student);
                } else {
                    passStudents.push_back(student);
                }
            }

            // Sort the failStudents and passStudents vectors
            sort(failStudents.begin(), failStudents.end(), compareStudents);
            sort(passStudents.begin(), passStudents.end(), compareStudents);
            auto endCategorization = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> readingTime = endCategorization - startCategorization;

            // Saving categorized data
            auto startSavingCategorized = std::chrono::high_resolution_clock::now();
            string filenameFail = "students" + to_string(numStudents) + "_fail.txt";
            string filenamePass = "students" + to_string(numStudents) + "_pass.txt";

            saveStudentDataToFileVector(filenameFail, failStudents);
            saveStudentDataToFileVector(filenamePass, passStudents);
            auto endSavingCategorized = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> savingCategorizedTime = endSavingCategorized - startSavingCategorized;

            cout << "Execution times for " << numStudents << " students:" << endl;
            cout << "Memory address of the data structure: " << &students << endl;
            cout << "Data generation and saving: " << generationTime.count() << " seconds" << endl;
            cout << "Reading: " << readingTime.count() << " seconds" << endl;
            cout << "Categorization: " << categorizationTime.count() << " seconds" << endl;
            cout << "Saving categorized data: " << savingCategorizedTime.count() << " seconds" << endl;
            cout << "------------------------" << endl;
            }

            return 0;
        }
    }
}

